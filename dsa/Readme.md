# Interview Prep
Data engineering interview preparation

## Data Structures & Algorithms

| Category | Link | Description | Approach | Complexity | Script Path |
|----------|------|-------------|-----------|------------|-------------|
| Arrays | [Two Sum](https://leetcode.com/problems/two-sum/) | Given an array of integers `nums` and a target integer, return indices of two numbers in `nums` that add up to target. Each input has exactly one solution and same element cannot be used twice. | 1. Use hash map to store visited numbers and indices<br>2. For each number, check if (target - current_number) exists in hash map<br>3. If found, return current index and stored index<br>4. If not found, store current number and index | Time: O(n)<br>Space: O(n) | [arrays/two_sum.py](arrays/two_sum.py) |
| Arrays | [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) | Given an array of stock prices, find the maximum profit by buying on one day and selling on a different day in the future. Return 0 if no profit possible. | 1. Keep track of minimum price seen so far (buying price)<br>2. For each price, calculate potential profit if we sell at current price<br>3. Update maximum profit if current profit is larger<br>4. Return maximum profit found | Time: O(n)<br>Space: O(1) | [arrays/buy_and_sell_stock.py](arrays/buy_and_sell_stock.py) |
| Arrays | [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) | Given an integer array nums, return true if any value appears at least twice, and false if all elements are distinct. | 1. Create a hash set to track seen numbers<br>2. Iterate through array<br>3. If number exists in set, return True<br>4. Add each new number to set<br>5. Return False if no duplicates found | Time: O(n)<br>Space: O(n) | [arrays/contains_duplicate.py](arrays/contains_duplicate.py) |
| Arrays | [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/) | Given an array nums, return array answer where answer[i] is equal to product of all elements except nums[i]. Must solve without division in O(n) time. | 1. First pass (Left to Right): Calculate prefix products for each position<br>2. Second pass (Right to Left): Multiply each position by suffix products<br>3. Each position gets product of all numbers to its left and right<br>4. Naturally skips the number at current position | Time: O(n)<br>Space: O(1) | [arrays/product_of_array_except_self.py](arrays/product_of_array_except_self.py) |
| Arrays | [Max Subarray](https://leetcode.com/problems/maximum-subarray/) | Given an integer array nums, find the contiguous subarray with the largest sum and return that sum. | 1. Initialize max_sum and current_sum to the first element.<br>2. Iterate through the array, updating current_sum and max_sum.<br>3. Return max_sum after processing all elements. | Time: O(n)<br>Space: O(1) | [arrays/max_subarray.py](arrays/max_subarray.py) |
| Arrays | [Max Product Subarray](https://leetcode.com/problems/maximum-product-subarray/) | Given an integer array nums, find a contiguous subarray within an array (containing at least one number) which has the largest product. | 1. Initialize max_product, min_product, and result to the first element.<br>2. Iterate through the array, updating max_product and min_product based on the current number.<br>3. Update result with the maximum product found. | Time: O(n)<br>Space: O(1) | [arrays/max_prod_subarray.py](arrays/max_prod_subarray.py) |